<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orb Dodger</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: none; /* Hide the default cursor over the canvas */
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 16px;
            text-align: left;
            min-width: 120px;
        }
        #health-bar-container {
            width: 100%;
            height: 12px;
            background-color: #555;
            border-radius: 6px;
            border: 1px solid #333;
            margin-top: 4px;
            overflow: hidden;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* Green */
            border-radius: 6px;
            transition: width 0.2s ease-in-out;
        }
        .game-over-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.75);
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            display: none; /* Hidden by default */
            font-size: 24px;
        }
        .game-over-modal h1 {
            margin: 0;
            font-size: 50px;
        }
        .game-over-modal p {
            margin: 15px 0;
        }
        .game-over-modal span {
            font-size: 18px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="info-panel">
        <p>Enemies: <span id="enemy-count">0</span></p>
        <p>Score: <span id="score">0</span></p>
        <p style="margin-bottom: 2px;">Health:</p>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
    </div>
    <div id="gameOverModal" class="game-over-modal">
        <h1>GAME OVER</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <span>Click anywhere to restart</span>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const enemyCountSpan = document.getElementById('enemy-count');
        const scoreSpan = document.getElementById('score');
        const healthBar = document.getElementById('health-bar');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreSpan = document.getElementById('finalScore');

        // Set canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Mouse object to store cursor position
        const mouse = {
            x: canvas.width / 2,
            y: canvas.height / 2
        };

        // --- Event Listeners ---
        window.addEventListener('mousemove', (event) => {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('click', () => {
            if (isGameOver) {
                init();
                animate();
            }
        });

        // --- Player Class ---
        class Player {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.health = 100; // Start with 100 health
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            update() {
                // Smoothly follow the mouse for a nice trailing effect
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                this.x += dx * 0.1;
                this.y += dy * 0.1;

                this.draw();
            }
        }

        // --- Enemy Class (This was missing) ---
        class Enemy {
            constructor(x, y, size, color, speed, type) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speed = speed;
                this.type = type; // 'triangle'
                this.chaseRange = 250; // The range at which they start chasing
                this.isChasing = false;
                
                // Determine initial velocity based on spawn location
                const angleToCenter = Math.atan2(canvas.height / 2 - this.y, canvas.width / 2 - this.x);
                this.velocityX = Math.cos(angleToCenter) * this.speed;
                this.velocityY = Math.sin(angleToCenter) * this.speed;
            }

            draw() {
                if (this.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.closePath();
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            update() {
                const dist = Math.hypot(player.x - this.x, player.y - this.y);

                if (dist < this.chaseRange) {
                    this.isChasing = true;
                } else {
                    // If it was chasing and player gets out of range, it stops chasing
                    if (this.isChasing) {
                        this.isChasing = false;
                    }
                }
                
                if(this.isChasing) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.velocityX = Math.cos(angle) * this.speed;
                    this.velocityY = Math.sin(angle) * this.speed;
                }

                this.x += this.velocityX;
                this.y += this.velocityY;

                this.draw();
            }
        }


        // --- Healing Orb Class ---
        class HealingOrb {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                // Add a glow effect to make it stand out
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.closePath();
                ctx.shadowBlur = 0; // Reset shadow blur for other elements
            }

            update() {
                this.draw();
            }
        }

        // --- Game Initialization ---
        let player;
        let enemies = [];
        let healingOrbs = [];
        let score = 0;
        let isGameOver = false;
        let animationId;
        let enemySpeedMultiplier;

        function init() {
            player = new Player(canvas.width / 2, canvas.height / 2, 15, '#0099ff');
            enemies = [];
            healingOrbs = [];
            score = 0;
            isGameOver = false;
            enemySpeedMultiplier = 1; // Reset multiplier on new game
            gameOverModal.style.display = 'none'; // Hide game over screen
            scoreSpan.textContent = 0;
            healthBar.style.width = '100%';
            healthBar.style.backgroundColor = '#4CAF50';
            enemyCountSpan.textContent = 0;
        }

        function spawnEnemy() {
            const size = Math.random() * 20 + 10;
            let x, y;

            // Spawn enemies from outside the screen
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? 0 - size : canvas.width + size;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? 0 - size : canvas.height + size;
            }

            const speed = (Math.random() * 1.5 + 0.5) * enemySpeedMultiplier;

            // Only spawn triangles, and make them slightly smaller
            const color = '#ff3333'; // Red
            enemies.push(new Enemy(x, y, size / 2, color, speed, 'triangle'));
        }

        function spawnHealingOrb() {
            // Limit the number of orbs on screen to 3
            if (healingOrbs.length < 3) {
                const radius = 10;
                // Spawn inside the canvas, with a buffer from the edges
                const x = Math.random() * (canvas.width - radius * 4) + radius * 2;
                const y = Math.random() * (canvas.height - radius * 4) + radius * 2;
                const color = '#33ff99'; // A nice green color
                healingOrbs.push(new HealingOrb(x, y, radius, color));
            }
        }


        // --- Animation Loop ---
        function animate() {
            animationId = requestAnimationFrame(animate);

            // Clear the canvas with a semi-transparent fill for a motion blur effect
            ctx.fillStyle = 'rgba(26, 26, 26, 0.25)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            player.update();

            let chasingEnemies = 0; // Counter for enemies chasing the player this frame
            
            // Using a reverse for-loop to safely remove enemies from the array
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.update();

                // --- Collision and Multiplier Logic ---
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                
                // Check if enemy is chasing for score multiplier
                if (dist < enemy.chaseRange) {
                    chasingEnemies++;
                }

                // If enemy hits player
                if (dist - enemy.size - player.radius < 1) {
                    player.health -= 10; // Decrease health by 10
                    healthBar.style.width = player.health + '%';
                    
                    // Change health bar color based on health
                    if (player.health <= 50) {
                        healthBar.style.backgroundColor = '#f44336'; // Red
                    } else if (player.health <= 70) {
                        healthBar.style.backgroundColor = '#ffeb3b'; // Yellow
                    }

                    enemies.splice(i, 1); // Remove the enemy that hit the player

                    // Check if player is out of health
                    if (player.health <= 0) {
                        healthBar.style.width = '0%';
                        cancelAnimationFrame(animationId); // Stop the game loop
                        isGameOver = true;
                        finalScoreSpan.textContent = Math.floor(score);
                        gameOverModal.style.display = 'block'; // Show game over screen
                    }
                }


                // Despawn logic: remove enemies that go completely off-screen
                const buffer = enemy.size * 2;
                if (enemy.x + buffer < 0 || 
                    enemy.x - buffer > canvas.width || 
                    enemy.y + buffer < 0 || 
                    enemy.y - buffer > canvas.height) {
                    enemies.splice(i, 1);
                }
            }

            // --- Healing Orb Logic ---
            for (let i = healingOrbs.length - 1; i >= 0; i--) {
                const orb = healingOrbs[i];
                orb.update();

                const dist = Math.hypot(player.x - orb.x, player.y - orb.y);

                // If player collects the orb
                if (dist - orb.radius - player.radius < 1) {
                    player.health += 20; // Heal for 20 HP
                    if (player.health > 100) {
                        player.health = 100; // Cap health at 100
                    }
                    healthBar.style.width = player.health + '%';
                    
                    // Update health bar color
                    if (player.health > 70) {
                        healthBar.style.backgroundColor = '#4CAF50'; // Green
                    } else if (player.health > 50) {
                        healthBar.style.backgroundColor = '#ffeb3b'; // Yellow
                    }
                    
                    healingOrbs.splice(i, 1);
                }
            }

            // Slowly increase the enemy speed multiplier over time
            // You can change 0.00005 to make them speed up faster or slower
            enemySpeedMultiplier += 0.00005;

            // Update score based on survival time and chasing enemies multiplier
            const baseScoreRate = 0.05; // Slower base score rate
            const multiplierBonus = chasingEnemies * 0.02; // Bonus per chasing enemy
            score += baseScoreRate + multiplierBonus;
            scoreSpan.textContent = Math.floor(score);

            enemyCountSpan.textContent = enemies.length;
        }

        // --- Start Game ---
        init();
        animate();

        // Spawn enemies periodically and more quickly
        setInterval(spawnEnemy, 750);
        // Spawn healing orbs less frequently
        setInterval(spawnHealingOrb, 8000);

    </script>
</body>
</html>


